import{_ as i,c as l,o as e,N as t}from"./chunks/framework.28867cbe.js";const g=JSON.parse('{"title":"微前端","description":"","frontmatter":{},"headers":[],"relativePath":"technology/Microfront/A-简介.md"}'),r={name:"technology/Microfront/A-简介.md"},a=t('<h1 id="微前端" tabindex="-1">微前端 <a class="header-anchor" href="#微前端" aria-label="Permalink to &quot;微前端&quot;">​</a></h1><h2 id="什么是微前端" tabindex="-1">什么是微前端 <a class="header-anchor" href="#什么是微前端" aria-label="Permalink to &quot;什么是微前端&quot;">​</a></h2><h2 id="市场方案" tabindex="-1">市场方案 <a class="header-anchor" href="#市场方案" aria-label="Permalink to &quot;市场方案&quot;">​</a></h2><h3 id="qiankun-阿里" tabindex="-1">qiankun - 阿里 <a class="header-anchor" href="#qiankun-阿里" aria-label="Permalink to &quot;qiankun - 阿里&quot;">​</a></h3><p>文档地址：<a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="noreferrer">https://qiankun.umijs.org</a></p><p><strong>优点</strong></p><ul><li>监听路由自动的加载、卸载当前路由对应的子应用</li><li>完备的沙箱方案，js沙箱做了SnapshotSandbox、LegacySandbox、ProxySandbox三套渐进增强方案，css沙箱做了两套strictStyleIsolation、experimentalStyleIsolation两套适用不同场景的方案</li><li>路由保持，浏览器刷新、前进、后退，都可以作用到子应用</li><li>应用间通信简单，全局注入</li></ul><p><strong>缺点</strong></p><ul><li>基于路由匹配，无法同时激活多个子应用，也不支持子应用保活</li><li>改造成本较大，从 webpack、代码、路由等等都要做一系列的适配</li><li>css 沙箱无法绝对的隔离，js 沙箱在某些场景下执行性能下降严重</li><li>无法支持 vite 等 ESM 脚本运行</li></ul><p><strong>成本上</strong>：</p><ul><li>接入成本：子应用需要接入生命周期代码；主应用需要接入注册微应用代码；</li><li>改造成本：需要自己考虑微前端工程化问题，以及微前端平台运维。</li></ul><p><strong>风险上</strong></p><ul><li>社区活跃度：star:：13.4k（2022-10-09） /star:14.2k（2023-4-1）</li><li>文档齐全，demo多</li></ul><h3 id="wujie-腾讯" tabindex="-1">wujie - 腾讯 <a class="header-anchor" href="#wujie-腾讯" aria-label="Permalink to &quot;wujie - 腾讯&quot;">​</a></h3><p>文档地址：<a href="https://wujie-micro.github.io/doc/" target="_blank" rel="noreferrer">无界</a></p><p>2022年7月份发布</p><p><strong>功能上</strong></p><ul><li>支持vite</li><li>多应用同时激活在线</li><li>框架具备同时激活多应用，并保持这些应用路由同步的能力</li><li>组件式的使用方式</li><li>无需注册，更无需路由适配，在组件内使用，跟随组件装载、卸载</li><li>应用级别的 keep-alive</li><li>子应用开启保活模式后，应用发生切换时整个子应用的状态可以保存下来不丢失，结合预执行模式可以获得类似ssr的打开体验</li><li>纯净无污染</li><li>无界利用iframe和webcomponent来搭建天然的js隔离沙箱和css隔离沙箱</li><li>利用iframe的history和主应用的history在同一个top-level browsing context来搭建天然的路由同步机制</li><li>副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本</li><li>性能和体积兼具</li><li>子应用执行性能和原生一致，子应用实例instance运行在iframe的window上下文中，避免with(proxyWindow){code}这样指定代码执行上下文导致的性能下降，但是多了实例化iframe的一次性的开销，可以通过 proload 提前实例化</li><li>体积比较轻量，借助iframe和webcomponent来实现沙箱，有效的减小了代码量</li></ul><p><strong>成本</strong></p><ul><li>开箱即用</li><li>不管是样式的兼容、路由的处理、弹窗的处理、热更新的加载，子应用完成接入即可开箱即用无需额外处理，应用接入成本也极低</li></ul><p><strong>风险</strong></p><ul><li>社区活跃度： star:1.7k（2022-10-09），star:2.4k（2023-4-1）</li><li>文档不是特别齐全</li><li>使用人数相对较少</li></ul><h3 id="mecro-app-京东" tabindex="-1">mecro-App - 京东 <a class="header-anchor" href="#mecro-app-京东" aria-label="Permalink to &quot;mecro-App - 京东&quot;">​</a></h3><p>文档地址：<a href="https://zeroing.jd.com/" target="_blank" rel="noreferrer">https://zeroing.jd.com/</a></p><p><strong>功能</strong></p><ul><li>抛弃了路由劫持的思路，选用类web component的方案</li><li>基于CustomElement和样式隔离、js隔离来实现微应用的加载，所以子应用无需改动就可以接入</li><li>支持应用隔离</li><li>通过劫持底层接口实现了元素隔离</li><li>提供了插件系统</li><li>支持预加载 <strong>缺点</strong></li><li>没有考虑工程化问题：如公用依赖，组件复用</li><li>没有考虑到微前端平台运维</li><li>不支持vite3</li></ul><p><strong>成本</strong></p><ul><li>接入成本：子应用无需改动，主应用需要接入微应用代码</li><li>改造成本：需要自己考虑微前端工程化问题，以及微前端平台运维。</li></ul><p><strong>风险</strong></p><ul><li>这个框架基于CustomElement和Proxy API，前者针对低版本有polyfill，但后者没有，且目前官方文档说没有做兼容的计划</li><li>社区活跃度：star:：3.5k（2022-10-09） /star:4.1k（2023-4-1）</li><li>文档齐全</li></ul>',30),o=[a];function n(s,p,c,u,h,d){return e(),l("div",null,o)}const _=i(r,[["render",n]]);export{g as __pageData,_ as default};
