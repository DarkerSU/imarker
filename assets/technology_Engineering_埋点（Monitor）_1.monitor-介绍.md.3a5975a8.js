import{_ as i,c as a,o as e,Q as t}from"./chunks/framework.11a869bf.js";const m=JSON.parse('{"title":"埋点","description":"","frontmatter":{},"headers":[],"relativePath":"technology/Engineering/埋点（Monitor）/1.monitor-介绍.md"}'),l={name:"technology/Engineering/埋点（Monitor）/1.monitor-介绍.md"},o=t('<h1 id="埋点" tabindex="-1">埋点 <a class="header-anchor" href="#埋点" aria-label="Permalink to &quot;埋点&quot;">​</a></h1><h2 id="埋点名词" tabindex="-1">埋点名词 <a class="header-anchor" href="#埋点名词" aria-label="Permalink to &quot;埋点名词&quot;">​</a></h2><h3 id="uv-unique-visitor" tabindex="-1">UV（Unique visitor） <a class="header-anchor" href="#uv-unique-visitor" aria-label="Permalink to &quot;UV（Unique visitor）&quot;">​</a></h3><p>是指通过互联网访问、浏览这个网页的自然人。访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。一天内同个访客多次访问仅计算一个UV。</p><h3 id="ip-internet-protocol" tabindex="-1">IP（Internet Protocol） <a class="header-anchor" href="#ip-internet-protocol" aria-label="Permalink to &quot;IP（Internet Protocol）&quot;">​</a></h3><p>独立IP是指访问过某站点的IP总数，以用户的IP地址作为统计依据。00:00-24:00内相同IP地址之被计算一次。</p><p>UV与IP区别</p><blockquote><p>如：你和你的家人用各自的账号在同一台电脑上登录新浪微博，则IP数+1，UV数+2。由于使用的是同一台电脑，所以IP不变，但使用的不同账号，所以UV+2</p></blockquote><h3 id="pv-page-view" tabindex="-1">PV（Page View） <a class="header-anchor" href="#pv-page-view" aria-label="Permalink to &quot;PV（Page View）&quot;">​</a></h3><p>即页面浏览量或点击量，用户每1次对网站中的每个网页访问均被记录1个PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。</p><h3 id="vv-visit-view" tabindex="-1">VV（Visit View） <a class="header-anchor" href="#vv-visit-view" aria-label="Permalink to &quot;VV（Visit View）&quot;">​</a></h3><p>用以统计所有访客1天内访问网站的次数。当访客完成所有浏览并最终关掉该网站的所有页面时便完成了一次访问，同一访客1天内可能有多次访问行为，访问次数累计。</p><p>PV与VV区别</p><blockquote><p>如：你今天10点钟打开了百度，访问了它的三个页面；11点钟又打开了百度，访问了它的两个页面，则PV数+5，VV数+2.PV是指页面的浏览次数，VV是指你访问网站的次数。</p></blockquote><h2 id="埋点分类" tabindex="-1">埋点分类 <a class="header-anchor" href="#埋点分类" aria-label="Permalink to &quot;埋点分类&quot;">​</a></h2><h3 id="代码埋点" tabindex="-1">代码埋点 <a class="header-anchor" href="#代码埋点" aria-label="Permalink to &quot;代码埋点&quot;">​</a></h3><p>通过代码的方式在页面中嵌入逻辑，比如捕获一个点击事件，在这个点击事件之前加入代码埋点,上报给后台。</p><p>国内已经有很多成型的服务商了如友盟，百度统计等，都提供了比较成型的方案，并可以在后台管理系统中查看比较详细的数据分析，但是肯定会有领导想要把这些事情掌握在自己的手中，我们就只能通过自身开发来实现代码埋点。</p><div class="tip custom-block"><p class="custom-block-title">优点</p><ul><li>控制精准，可以非常精确地选择什么时候发送数据。</li><li>传递多样化自定义属性、自定义事件，传递比较丰富的数据到服务端。</li></ul></div><div class="warning custom-block"><p class="custom-block-title">缺点</p><ul><li>埋点代价比较大，每一个控件的埋点都需要添加相应的代码，不仅工作量大，必须是技术人员才能完成。</li><li>更新的代价比较大，每一次更新埋点方案，都必须改代码。</li></ul></div><h3 id="可视化埋点" tabindex="-1">可视化埋点 <a class="header-anchor" href="#可视化埋点" aria-label="Permalink to &quot;可视化埋点&quot;">​</a></h3><p>个人理解的可视化埋点应该是肯定需要第三方的服务商支持，不会有做专门业务的公司去做可视化埋点的解决方案。</p><p>可视化埋点开发人员除集成采集可视化SDK外，不需要额外去写埋点代码，而是由业务人员或运营人员通过访问分析平台的圈选功能，来“圈”出需要对用户行为进行捕捉的控件，并给出事件命名。圈选完毕后，这些配置会同步到各个用户的终端上，由采集SDK按照圈选的配置自动进行用户行为数据的采集和发送。</p><div class="tip custom-block"><p class="custom-block-title">优点：</p><ul><li>埋点代价小，更新代价小</li><li>埋点只需业务同学接入，开发只需对接可视化SDK</li></ul></div><div class="warning custom-block"><p class="custom-block-title">缺点：</p><ul><li>无法做到自定义获取数据</li><li>可视化埋点覆盖的功能有限</li><li>仅支持客户端行为</li></ul></div><h3 id="无痕埋点" tabindex="-1">无痕埋点 <a class="header-anchor" href="#无痕埋点" aria-label="Permalink to &quot;无痕埋点&quot;">​</a></h3><p>无痕埋点又叫全埋点，网上又很多文章写的都是无痕埋点是将所有事件的操作全部上报，但是我们在实现的过程中肯定是不会监听那么多的事件吧，但是好像也有第三方服务商sdk集成了所有事件。</p><div class="tip custom-block"><p class="custom-block-title">优点：</p><ul><li>由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象。</li><li>无埋点方式因为收集的是全量数据，可以大大减少运营和产品的试错成本</li><li>如果集成sdk之后无需埋点，方便快捷</li></ul></div><div class="warning custom-block"><p class="custom-block-title">缺点：</p><ul><li>缺点与可视化埋点相同，未解决个性化自定义获取数据的问题，缺乏数据获取的灵活性；</li><li>数据量过大，如果不使用第三方服务商，针对自身的服务器是个考验</li></ul></div>',29),r=[o];function s(c,n,u,p,h,d){return e(),a("div",null,r)}const v=i(l,[["render",s]]);export{m as __pageData,v as default};
