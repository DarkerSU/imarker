import{_ as o,c as e,o as c,N as d}from"./chunks/framework.cd9250a1.js";const l="/images/engineering/构建工具排点.png",m=JSON.parse('{"title":"前端构建工具大盘点","description":"","frontmatter":{},"headers":[],"relativePath":"technology/Engineering/前端构建工具大盘点.md"}'),a={name:"technology/Engineering/前端构建工具大盘点.md"},t=d('<h1 id="前端构建工具大盘点" tabindex="-1">前端构建工具大盘点 <a class="header-anchor" href="#前端构建工具大盘点" aria-label="Permalink to &quot;前端构建工具大盘点&quot;">​</a></h1><blockquote><p>Webpack 是一个模块打包工具，可以将各种资源文件（如 JavaScript、CSS、图片等）视为模块，在打包时统一处理和优化。它的主要作用是将多个模块打包成一个或多个文件，并对这些文件进行优化和压缩，以提高页面加载速度和用户体验。</p></blockquote><p>本文来盘点目前流行的前端构建工具。</p><h2 id="构建工具大pk" tabindex="-1">构建工具大PK <a class="header-anchor" href="#构建工具大pk" aria-label="Permalink to &quot;构建工具大PK&quot;">​</a></h2><img src="'+l+'"><h2 id="webpack" tabindex="-1">Webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;Webpack&quot;">​</a></h2><p><code>Webpack</code> 是一个模块打包工具，可以将各种资源文件（如 <code>JavaScript</code>、<code>CSS</code>、图片等）视为模块，在打包时统一处理和优化。它的主要作用是将多个模块打包成一个或多个文件，并对这些文件进行优化和压缩，以提高页面加载速度和用户体验。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>模块化支持</strong>：<code>Webpack</code> 支持 <code>CommonJS</code>、<code>AMD</code>、<code>ES6</code> 等多种模块化规范，可以将各种资源文件视为模块进行处理和打包，并自动识别依赖关系。</li><li><strong>高度可配置的构建流程</strong>：<code>Webpack</code> 提供了各种插件和加载器处理各种资源文件，并支持自定义配置文件，使得开发者可以通过简单的配置调整编译过程和输出结果，实现高度可配置的构建流程。</li><li><strong>开箱即用的解决方案</strong>：<code>Webpack</code> 提供了一套开箱即用的解决方案，包括 <code>DevServer</code>、<code>HotModuleReplacementPlugin</code>、<code>SourceMap</code> 等，可以满足大多数 <code>Web</code> 应用程序的需求。同时，<code>Webpack</code> 还支持多种模式，如 <code>production</code> 和 <code>development</code> 模式，可以根据需要进行优化和调试。</li><li><strong>插件系统</strong>：<code>Webpack</code> 有着强大的插件系统，可以通过加载各种插件实现打包、优化、代码分离等复杂功能。<code>Webpack</code> 插件可以与加载器结合使用，提供更丰富的功能。</li><li><strong>生态丰富</strong>：<code>Webpack</code> 有着庞大的生态系统，涵盖了众多的插件、加载器和工具，可以方便地扩展和定制。</li></ul></div><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><strong>构建速度较慢</strong>：由于 <code>Webpack</code> 需要将各种资源文件合并、处理和输出，因此在打包大型项目时，构建速度可能会较慢。</li><li><strong>体积较大</strong>：由于 <code>Webpack</code> 需要将所有代码转换为模块，并引入一些必要的运行时依赖，因此输出的文件往往较大，可能会影响应用的加载速度</li><li><strong>配置复杂</strong>：尽管 <code>Webpack</code> 提供了很多的功能和自定义选项，但是其配置文件往往较为复杂，需要考虑到多个方面，如入口、输出、模块、插件等。</li><li><strong>依赖项管理</strong>：<code>Webpack</code> 的依赖项管理比较复杂，尤其是在处理复杂的依赖关系时，可能会出现依赖冲突、依赖循环、依赖丢失等问题。</li></ul></div><h2 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h2><p><code>Vite</code> 是一个基于浏览器原生 <code>ES</code> 模块化进行开发的前端构建工具，旨在提供一种更快、更简单的开发体验。</p><h3 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>快速的开发服务器</strong>：<code>Vite</code> 使用了浏览器内置的 <code>ES</code> 模块化支持，从而可以实现“按需编译、按需加载”的特性，使得开发服务器可以快速响应页面请求，无需等待整个项目打包完成。</li><li><strong>热更新</strong>：<code>Vite</code> 使用了浏览器原生的模块热更新技术，能够实现组件级别的热更新，减少了开发时的刷新时间和手动刷新的次数。</li><li><strong>支持多种前端框架</strong>：<code>Vite</code> 不仅支持 <code>Vue.js</code>，还支持 <code>React</code>、<code>Preact</code>、<code>Svelte</code> 和 <code>Lit</code>等多种前端框架。</li><li><strong>内置了 Rollup</strong>：<code>Vite</code> 内置了 <code>Rollup</code>，可以处理各种类型的文件，如 <code>JS</code>、<code>CSS</code>、<code>HTML</code>、<code>JSON</code> 等，同时支持各种模块化规范，如 <code>CommonJS</code>、<code>ESM</code>、<code>AMD</code> 等。</li><li><strong>插件系统</strong>：<code>Vite</code> 提供了插件系统，可以扩展和定制 <code>Vite</code> 的功能，例如使用 <code>TypeScript</code>、<code>Sass</code> 等。</li><li><strong>简单易用</strong>：相对于 Webpack <code>来说，Vite</code> 的配置更加简单明了，许多默认配置已经足够满足大多数前端项目的需求。</li></ul></div><h3 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><strong>对于旧浏览器支持较差</strong>：由于 <code>Vite</code> 采用了 <code>ES</code> 模块化和原生浏览器 <code>APIs</code>，因此在旧版本的浏览器中可能会出现兼容性问题。</li><li><strong>与 <code>CommonJS</code> 模块不完全兼容</strong>：由于 <code>Vite</code> 采用的是 <code>ES</code> 模块化规范，而 <code>CommonJS</code> 模块是 <code>Node.js</code> 原生支持的模块化规范，在使用一些 <code>CommonJS</code> 模块时，需要将其转换为 <code>ES</code> 模块，否则可能会导致一些编译错误。但是 <code>Vite</code> 提供了一些插件和工具，例如 <code>rollup-plugin-commonjs</code>、<code>@rollup/plugin-node-resolve</code> 等，可以在一定程度上解决这些问题。</li></ul></div><h2 id="parcel" tabindex="-1">Parcel <a class="header-anchor" href="#parcel" aria-label="Permalink to &quot;Parcel&quot;">​</a></h2><p><code>Parcel</code> 是一个用 Rust 编写的快速、零配置的前端构建工具，旨在消除 <code>Webpack</code> 和 <code>Browserify</code> 等传统构建工具的复杂性和配置。<code>Parcel </code>使用多核编译来提供快速高效的构建，使其成为中小型项目的理想选择。</p><p>使用 <code>Parcel</code> 的主要好处之一是它能够自动检测和安装项目所需的依赖项。这意味着开发人员可以专注于编写代码，而不是管理依赖项和配置。此外，<code>Parcel</code> 还提供灵活的插件系统，允许开发人员根据项目需求添加或删除特定功能来自定义构建。</p><h3 id="优点-2" tabindex="-1">优点 <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>零配置</strong>: <code>Parcel</code> 是一款零配置的打包工具，使用者不用编写冗长的配置文件即可完成前端打包操作。这使得开发者能够快速上手，并且在开发过程中节省大量时间。</li><li><strong>自动化</strong>：<code>Parcel</code> 支持自动识别 <code>JavaScript、CSS、HTML</code> 文件等，并根据内容类型自动化地进行转换和处理。例如，<code>Parcel</code> 自动压缩代码、自动优化图像等等，减少了手动处理的工作量。</li><li><strong>易于维护</strong>：<code>Parcel</code> 打包后生成的输出代码是易于阅读和维护的，这意味着即便是没有直接参与项目开发的人也能够很容易地理解代码结构和逻辑。</li><li><strong>支持多种技术栈</strong>：<code>Parcel</code> 对多种技术栈提供了支持，包括了 <code>React、Vue、Angular、TypeScript</code> 等。同时，<code>Parcel</code> 对多种资源类型提供了支持，例如图片、字体、视频等。</li><li><strong>快速</strong>：<code>Parcel</code> 采用了多进程并行处理的方式，在提高打包速度的同时还能够减少打包过程中对电脑系统资源的占用，使得开发者在开发过程中更加流畅。</li></ul></div><h3 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><strong>生态不够完善</strong>：与<code>Webpack</code>等其他构建工具相比，<code>Parcel</code>的生态系统还比较弱，一些插件和库的支持还不够完善，可能需要开发者自己手动配置。</li><li><strong>配置项较少</strong>：由于<code>Parcel</code>是一个零配置的打包器，因此它的配置选项相对较少。</li><li><strong>缺少高级功能</strong>：虽然<code>Parcel</code>可以自动优化代码并支持热更新，但与Webpack等其他打包器相比，它缺少一些高级功能，例如<code>Tree Shaking</code>等。</li></ul></div><h2 id="esbuild" tabindex="-1">esbuild <a class="header-anchor" href="#esbuild" aria-label="Permalink to &quot;esbuild&quot;">​</a></h2><p>esbuild 是一款速度极快的 JavaScript 捆绑器和压缩器，可显着缩短构建时间并提高整体性能。esbuild 由 Evan Wallace 开发，旨在成为市场上最快的 JavaScript 捆绑器和压缩器，其构建时间比竞争对手快 100 倍。</p><h3 id="优点-3" tabindex="-1">优点 <a class="header-anchor" href="#优点-3" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>极快速</strong>：<code>esbuild</code> 的编译速度非常快，相比其他流行的 <code>JavaScript</code> 编译器和打包器，它的速度最多可以快 100 倍。<code>esbuild</code> 使用 Go 语言编写，并使用了大量优化技巧和并发处理，这使得它能够更快地完成代码编译和打包操作。</li><li><strong>通用性</strong>：<code>esbuild</code> 支持多种模块格式，包括 <code>CommonJS、ES6</code> <code>模块、AMD</code> 等，使得它适用于任何类型的 <code>JavaScript</code> 项目。此外，esbuild 同样适用于 TypeScript 项目，可以直接编译 TypeScript 文件，并支持源映射和类型检查等功能。</li><li><strong>易于使用</strong>：<code>esbuild</code> 的配置非常简单，只需要提供一个入口文件和输出目录即可。<code>esbuild</code> 还提供了许多选项，允许开发者进行更高级的配置，以满足特定需求。</li><li><strong>高级压缩</strong>：<code>esbuild</code> 可以应用各种高级的代码压缩技术，包括代码混淆、无效代码删除和变量名缩短等，从而产生更小、更快的代码包。与其他一些打包工具不同，<code>esbuild</code> 的压缩时间不会随着项目规模的增加而增加。</li><li><strong>静态分析</strong>：<code>esbuild</code> 在编译代码时会进行静态分析，优化代码结构和减少生成的代码大小。这种分析技术使得生成的代码更加简洁，同时在运行时也可以提高代码的性能表现。</li></ul></div><h3 id="缺点-3" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-3" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><strong>对于某些特定场景的支持不完善</strong>：相较于其他打包工具，<code>esbuild</code> 在一些特定场景下的支持并不完全。例如，如果项目需要使用 <code>Web Workers</code> 或 <code>Service Worker</code>，需要手动实现一些额外的配置和代码。但是，在许多常见的应用场景下，<code>esbuild</code> 的表现要明显好于其他打包工具。</li><li><strong>配置灵活度不高</strong>：虽然 <code>esbuild</code> 的配置非常简单，但相对于其他打包工具，它的灵活性略有不足。因为它侧重于快速且轻量级的构建，没有提供一些复杂的插件或高级配置选项。对于那些需要进行更多类似预处理、自定义样式等操作的项目，可能需要使用其他打包工具或者搭配其他工具来实现。</li><li><strong>生态不完善</strong>：较小的插件生态系统、较少的配置选项以及缺乏可定制性。<code>esbuild</code> 相对较新，因此可以期望它在未来几年中不断发展和改进。</li></ul></div><h2 id="gulp" tabindex="-1">Gulp <a class="header-anchor" href="#gulp" aria-label="Permalink to &quot;Gulp&quot;">​</a></h2><p><code>Gulp</code>是一个基于<code>Node.js</code>的自动化构建工具，用于简化开发过程中的任务处理，例如文件压缩、合并、重命名、图片压缩等。<code>Gulp</code>具有快速、简单、易用的特点，能够帮助开发者更加高效地完成各种任务。</p><p><code>Gulp</code>的核心思想是“流”，它通过将数据流传递到各种插件中来处理各种任务。<code>Gulp</code>的插件很容易编写和使用，可以通过NPM安装，同时<code>Gulp</code>还支持大量的插件，包括<strong>文件处理</strong>、<strong>CSS处理</strong>、<strong>JavaScript处理</strong>、<strong>图片处理</strong>等。</p><div class="tip custom-block"><p class="custom-block-title">Gulp 的工作流程如下</p><ol><li>定义任务：开发者通过编写Gulpfile.js文件来定义任务。</li><li>加载插件：使用NPM安装所需的Gulp插件，并在Gulpfile.js中进行加载。</li><li>定义任务流程：使用Gulp的API来定义任务流程，将数据流传递到各种插件中进行处理。</li><li>执行任务：使用Gulp的命令行工具来执行任务。</li></ol></div><h3 id="优点-4" tabindex="-1">优点 <a class="header-anchor" href="#优点-4" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>易用性</strong>：<code>Gulp</code> 采用了类似于流的方式，可以通过简单的 <code>API</code> 对文件进行操作，相对其他构建工具如 <code>Grunt</code> 等而言，<code>Gulp</code> 的语法更加简洁，易于上手学习。</li><li><strong>速度快</strong>：<code>Gulp</code> 基于 <code>Node.js</code> 平台，使用了流式操作和内存缓存等机制，能够高效地处理大量的文件操作，在构建时间和速度上比其他构建工具更快。</li><li><strong>可扩展性</strong>：<code>Gulp</code> 使用了插件机制，开发者可以根据自己的需求选择适合的插件，并将它们组装起来，以完成各种不同的构建任务。</li><li><strong>可定制性</strong>：<code>Gulp</code> 的插件机制非常灵活，开发者可以根据自己的需要开发特定的插件，同时也可以结合其他构建工具或框架使用，以满足不同的需求。</li><li><strong>跨平台</strong>：由于 <code>Gulp</code> 是基于 <code>Node.js</code> 编写的，因此可以在多个操作系统上运行，包括 <code>Windows</code>、<code>Mac OS</code> 和 <code>Linux</code> 等。</li><li><strong>生态丰富</strong>：<code>Gulp</code> 生态环境较为成熟，拥有大量插件和工具，可以实现许多自动化构建任务，例如压缩 CSS/JS 文件、自动刷新浏览器、自动生成文档等。</li></ul></div><h3 id="缺点-4" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-4" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><strong>配置复杂</strong>：尽管<code>Gulp</code>的自由配置是其灵活性的体现，但在处理复杂的构建需求时，它的配置可能变得相对复杂和冗长。一些复杂的任务可能需要额外的配置和插件组合，增加了配置的复杂性和维护成本。</li><li><strong>功能较少</strong>：与其他构建工具相比，<code>Gulp</code> 提供的功能相对较少，例如没有 Grunt 提供的大量任务和插件。因此，需要根据实际需求进行插件的选择和配置。</li><li><strong>性能</strong>：<code>Gulp</code>的构建过程基于流<code>（stream）</code>的概念，这在一些场景下可能导致<strong>额外的内存开销</strong>和<strong>性能损耗</strong>。</li></ul></div><h2 id="swc" tabindex="-1">SWC <a class="header-anchor" href="#swc" aria-label="Permalink to &quot;SWC&quot;">​</a></h2><p><code>SWC（“Speedy Web Compiler”）</code>是一个快速且现代的 <code>JavaScript/TypeScript</code> 编译器，为 <code>Babel</code> 提供了更快、更高效的替代方案，旨在成为 <code>Babel</code> 的直接替代品，具有更快的编译时间和更好的性能。</p><p><code>SWC</code> 通过使用基于 <code>Rust</code> 的编译器来实现快速编译，该编译器比 Babel 基于 <code>JavaScript</code> 的编译器要快得多。这使得 <code>SWC</code> 能够提供更快、更高效的构建，并显着缩短构建时间和整体性能。</p><h3 id="优点-5" tabindex="-1">优点 <a class="header-anchor" href="#优点-5" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>高性能</strong>：<code>swc</code> 在编译速度上比 <code>Babel</code> 快很多倍，这得益于它采用了 <code>Rust</code> 这种高性能语言作为开发语言。<code>swc</code> 也支持多线程编译，可以更好地利用多核 <code>CPU</code> 资源来加速编译过程。此外，与 <code>Babel</code> 不同，<code>swc</code> 直接将代码解析成 <code>AST</code>，避免了 <code>Babel</code> 对于其他语法库的依赖，进一步提升了性能。</li><li><strong>压缩效果</strong>：<code>swc</code> 以 <code>&quot;super-fast and pure&quot;</code> 为目标，不仅在编译速度方面表现出色，同时还能产生比 <code>Babel</code> 更小、更高效的代码。<code>swc</code> 提供了多种压缩选项，例如删除未使用代码、混淆变量名、转换 <code>ECMAScript</code> 模块等，可以根据需要调整。</li><li><strong>支持 TypeScript</strong>：除了 <code>JavaScript</code> 编译之外，<code>swc</code> 还支持 <code>TypeScript</code> 编译，并且可以与 <code>React、Vue</code> 等主流前端框架集成。swc 可以直接将 <code>TypeScript</code> 代码编译成 <code>JavaScript</code> 代码，使项目代码更加易于维护和修改。</li><li><strong>易于集成</strong>：<code>swc</code> 的 <code>API</code> 友好且易于使用，可以集成到现有的构建系统中。<code>swc</code> 支持 <code>webpack、rollup、Parcel</code> 等主流构建工具，并且可以通过 <code>npm</code> 安装。</li></ul></div><h3 id="缺点-5" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-5" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><strong>插件生态相对薄弱</strong>：相对于其他工具，如 <code>Babel</code>，<code>swc</code> 的插件生态还比较薄弱。虽然 <code>swc</code> 已经有了一些常用插件，例如 TypeScript 转换和代码压缩等，但是可能无法满足所有的需求，需要开发者自行处理。</li><li><strong>兼容性问题</strong>：由于 <code>swc</code> 是新近出现的工具，并且使用 <code>Rust</code> 进行开发，因此可能存在一些兼容性问题。例如，与其他工具或库的集成可能需要额外的修改或调整，而某些外部库可能无法与 <code>swc</code> 兼容。</li></ul></div><h2 id="rollup" tabindex="-1">Rollup <a class="header-anchor" href="#rollup" aria-label="Permalink to &quot;Rollup&quot;">​</a></h2><p><code>Rollup</code>是一个<code>JavaScript</code>模块打包器，可以将<code>JavaScript</code>模块打包成单个文件。与其他打包工具相比，<code>Rollup</code>更加注重ES6模块的支持，可以将ES6模块转换成ES5模块，并可以进行<code>tree-shaking</code>优化，减小打包后文件的体积。<code>Rollup</code> 的目标是产生更小、更快、更高效的代码，因此在构建 <code>JavaScript</code> 库时非常有用。</p><p><code>Rollup</code> 背后的基本思想是获取一组输入模块，分析它们，然后生成一个输出文件，其中仅包含运行应用程序所需的代码。它旨在与现代<code>JavaScript</code> 模块很好地配合使用，例如用 ES6 或 TypeScript 编写的模块。它还可以处理许多流行的库和框架使用的 CommonJS 模块。<code>Rollup</code> 提供了一个插件架构，允许开发人员扩展其功能并与其他工具和工作流程集成。</p><h3 id="优点-6" tabindex="-1">优点 <a class="header-anchor" href="#优点-6" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>Tree shaking</strong>：<code>Rollup</code> 内置了 <code>Tree shaking</code>，可以静态分析代码并仅打包项目中实际使用的部分。这意味着生成的包大小更小，加载速度更快，并且可以避免不必要的代码执行。</li><li><strong>ES6 模块支持</strong>：<code>Rollup</code> 支持 ES6 模块语法，这是 <code>JavaScript</code> 标准化的一部分，并且在现代浏览器和 <code>Node.js</code> 中得到支持。这使得 <code>Rollup</code> 可以在 <code>ES6</code> 模块之间进行静态分析，从而优化结果代码。</li><li><strong>插件系统</strong>：<code>Rollup</code> 具有强大的插件系统，可以对输入代码和输出结果进行各种转换和处理。例如，插件可以将 <code>TypeScript</code> 代码转换为 <code>JavaScript</code>，将 <code>CSS</code> 文件转换为 <code>JS</code> 模块，或者压缩最终生成的代码等。</li><li><strong>对第三方库的支持</strong>：<code>Rollup</code> 的插件系统还可以与第三方库进行集成，例如 <code>React 和 Vue.js </code>等主流框架。这些插件可将框架组件标记为外部依赖项，从而避免多次重复地打包同一份代码。</li><li><strong>多种输出格式</strong>：<code>Rollup</code>支持多种输出格式，包括<code>CommonJS、AMD、UMD、ES6</code>等。</li></ul></div><h3 id="缺点-6" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-6" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><strong>复杂性高</strong>：相对于其他打包器来说，<code>Rollup</code> 的学习曲线可能会更陡峭一些，因为它的配置需要更多的了解。特别是在某些情况下，例如需要处理像图片和字体这样的非 <code>JavaScript</code> 资源时，可能需要使用其他附加插件或工具。</li><li><strong>对部分 CommonJS 模块支持不足</strong>：由于 <code>Rollup</code> 是专门为 <code>ES6</code> 模块设计的，对于使用 <code>CommonJS</code> 格式编写的库的支持较弱。虽然 <code>Rollup</code> 通过插件可以支持 <code>CommonJS</code>，但不是所有的库都适用于这种方式，这可能导致在打包时出现问题。</li></ul></div><h2 id="rome" tabindex="-1">Rome <a class="header-anchor" href="#rome" aria-label="Permalink to &quot;Rome&quot;">​</a></h2><p>Rome 是一个用于构建现代 JavaScript 应用程序的一体化工具链。Rome 由 Facebook 团队开发，旨在提供一种统一且简化的方法来构建、测试和部署 JavaScript 应用程序。</p><p>与传统构建工具相比，Rome 提供了许多优势，包括更快的构建时间、改进的错误处理和更好的性能。Rome 通过使用专为性能和可扩展性而设计的现代模块化架构来实现这些优势。</p><p>此外，Rome 还提供了许多用于提高开发人员生产力的工具，包括自动检查、格式化和测试。这使得开发人员更容易专注于编写高质量的代码，而不用担心构建过程的细节。</p><h3 id="优点-7" tabindex="-1">优点 <a class="header-anchor" href="#优点-7" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>统一的 AST</strong>：一个常见的问题是不同的工具使用不同的 AST 会导致解析速度变慢和数据流传递困难。为了解决这个问题，Rome 使用了一个单一的、统一的 AST，从而使得不同的工具可以更加高效地协作完成任务。</li><li><strong>类型检查</strong>：Rome 支持 JavaScript 类型检查，这意味着在编译代码之前就可以快速发现错误和警告。并且，与其他类型检查工具不同的是，它预置了许多内置的类型定义，能够自动的检查 DOM API 和浏览器环境 API 的正确性。</li><li><strong>零配置理念</strong>：Rome 遵循零配置的理念，这意味着无需配置即可使用，同时也没有复杂的默认配置，用户可以任意自定义。</li><li><strong>完全重新设计的工具链</strong>：Rome 没有基于传统工具链（例如 webpack 和 babel），而是完全重新设计了一系列工具，包括 linter、编译器、文件系统、打包器、测试框架等。</li><li><strong>多语言支持</strong>：除了 JavaScript，Rome 还计划支持许多其他语言，例如 TypeScript、Python、Ruby、Java、C++ 等。</li></ul></div><h3 id="缺点-7" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-7" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><code>仍然处于早期开发阶段</code>：尽管 Rome 意图成为一个综合性的、更好的 JavaScript 工具链，但它仍然处于早期的开发阶段，因此可能会存在许多 bug 或缺陷。同时，在某些情况下，Rome 可能会与其他依赖项不兼容，并需要进行额外的配置以解决问题。</li><li><code>可能对资源消耗较高</code>：由于 Rome 采用了不同于传统工具链的方法来处理JavaScript代码，因此可能需要更多的计算资源才能进行编译和构建。在处理大型项目时，这可能会导致构建时间较长或占用更多的计算资源。</li></ul></div><h2 id="turbopack" tabindex="-1">Turbopack <a class="header-anchor" href="#turbopack" aria-label="Permalink to &quot;Turbopack&quot;">​</a></h2><p><code>Turbopack</code> 是一个用于构建高性能 <code>JavaScript</code> 应用的工具。它旨在通过优化 <code>JavaScript</code> 应用的打包流程来提高应用程序的性能，缩短加载时间，减少 <code>CPU</code> 和网络资源的使用，并减少应用的体积和加载时间。<code>Vercel</code> 声称 <code>Turbopack</code> 是 <code>Webpack</code> 的继任者，用 Rust 编写，在大型应用中，展示出了 10 倍于 Vite、700 倍于 <code>Webpack</code> 的速度。</p><p>与传统的 <code>JavaScript</code> 打包工具（如 <code>webpack、Rollup</code>）不同，<code>Turbopack</code> 不需要手动创建配置文件或处理复杂的插件和依赖关系。相反，<code>Turbopack</code> 通过分析应用并自动检测应用程序中使用的运行时特性来确定必需的依赖项，并使用标准化的、高性能的 <code>JavaScript</code> 模块打包器 <code>Rollup</code> 来打包应用程序。</p><h3 id="优点-8" tabindex="-1">优点 <a class="header-anchor" href="#优点-8" aria-label="Permalink to &quot;优点&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><strong>自动计算依赖</strong>：Turbopack 不需要手动配置打包规则或外部依赖项，而是自动计算应用程序所需的所有依赖项，并通知您何时需要更新。</li><li><strong>快速的打包速度</strong>：Turbopack 非常快，因为它使用 Rollup 打包器作为内置打包工具，并且针对性能和大小进行了优化。</li><li><strong>智能增量编译</strong>：Turbopack 可以智能地检测到更改并只编译修改过的文件，这意味着即使在大型项目中也可以获得非常快的构建时间。</li><li><strong>内置 AST 转换</strong>：Turbopack 使用 esbuild 库内置了支持AST转换的功能，它可以执行类似于 Babel 的操作，例如转换 ES6 代码、JSX、TypeScript 等，并且速度非常快。</li><li><strong>在底层使用 SWC</strong>：它在底层使用 SWC，因此它将支持 SWC 支持的任何 ES 功能。</li></ul></div><h3 id="缺点-8" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-8" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><strong>可定制化程度低</strong>：Turbopack 的自动计算依赖项和智能增量编译功能是其最大的优点之一，但这也意味着无法像 webpack 一样精细地对打包过程进行定制。对于某些项目，可能需要更多的控制来针对性地优化打包规则和依赖。</li><li><strong>仍处于早起阶段</strong>：Turbopack 尚未得到像 webpack 或其他主流打包工具那样的广泛认可和支持，仍然处于早起开发阶段。</li></ul></div>',67),i=[t];function r(s,n,p,u,g,b){return c(),e("div",null,i)}const k=o(a,[["render",r]]);export{m as __pageData,k as default};
